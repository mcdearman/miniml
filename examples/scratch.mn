gcd : Int -> Int -> Int
gcd a 0 = a
gcd a b = gcd b (a % b)

lcm : Int -> Int -> Int
lcm a b = a * b / gcd a b

@pub
sieve : [Int] -> [Int]
sieve [] = []
sieve (p :: xs) = p :: sieve [x | x <- xs, x `mod` p > 0]

fib : Int -> Int
fib n = loop n 0 1
  where
    loop 0 a _ = a
    loop i a b = loop (i - 1) b (a + b)

fibs : [Integer]
fibs = 0 :: 1 :: zipWith (+) fibs (drop 1 fibs)

-- naive recursive factorial
fact : Int -> Int
fact 0 = 1
fact n = n * fact (n - 1)

fact : Int -> Int
fact = go 1
  where
    go acc 0 = acc
    go acc n = go (acc * n) (n - 1)

-- type alias
type Point = (Int, Int)

-- records
record Person { 
  name : String, 
  age : Int,
}

-- or with indentation
record Person
  name : String
  age : Int

-- We can use initializer syntax to create instances of structs.
-- Notice that we don't need to specify the record name. MiniML will
-- infer the type based on the fields.
def alice = { name = "Alice", age = 30 }

-- If there are two structs with identical fields, we can use the
-- record name to disambiguate.
def bob = Person { name = "Bob", age = 25 }

-- By default record fields are private. We can make them public by using
-- the `pub` keyword.
@pub
@derive(Debug, Show, Eq)
record Person {
  @pub name : String,
  age : Int,
}

-- or we can use `@pub(..)` on the record itself to make all fields public.
@pub(..)
@derive(Debug, Show, Eq)
record Person {
  name : String,
  age : Int,
}

-- We can update record fields using the `with` keyword. This creates a new
-- record with the specified fields updated.
alice = { name = "Alice", age = 30 }
alice' = { alice with age = 31 }

-- We can also update nested fields.
record Address { city : String, zip : Int }
record Person { name : String, age : Int, address : Address }

alice = { name = "Alice", age = 30, address = { city = "New York", zip = 10001 } }
alice' = { alice with address.city = "San Francisco" }

-- sum types
data Option a = None | Some a

data List a = Empty | Pair a (List a)

data List a = [] | a :: List a

data NonEmptyList a = NonEmpty a (List a)

-- with infix constructors
data NomEmptyList a = a :| List a

@infixr(5)
(|>) : a -> (a -> b) -> b
x |> f = f x

-- function composition is represented by `&`
(&) : (b -> c) -> (a -> b) -> a -> c
f & g = \x -> f (g x)

[1, 2, 3]
  |> map (+ 1)
  |> filter ((== 0) & (% 2))
  |> foldl' (+) 0
